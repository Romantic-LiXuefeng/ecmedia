// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SyncMsgResp.proto

#ifndef PROTOBUF_SyncMsgResp_2eproto__INCLUDED
#define PROTOBUF_SyncMsgResp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SyncMsgResp_2eproto();
void protobuf_AssignDesc_SyncMsgResp_2eproto();
void protobuf_ShutdownFile_SyncMsgResp_2eproto();

class SyncMsgRespInner;
class InstantMessage;

// ===================================================================

class SyncMsgRespInner : public ::cloopen_google::protobuf::MessageLite {
 public:
  SyncMsgRespInner();
  virtual ~SyncMsgRespInner();

  SyncMsgRespInner(const SyncMsgRespInner& from);

  inline SyncMsgRespInner& operator=(const SyncMsgRespInner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncMsgRespInner& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncMsgRespInner* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncMsgRespInner* other);

  // implements Message ----------------------------------------------

  SyncMsgRespInner* New() const;
  void CheckTypeAndMergeFrom(const ::cloopen_google::protobuf::MessageLite& from);
  void CopyFrom(const SyncMsgRespInner& from);
  void MergeFrom(const SyncMsgRespInner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::cloopen_google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::cloopen_google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .InstantMessage syncMessages = 1;
  inline int syncmessages_size() const;
  inline void clear_syncmessages();
  static const int kSyncMessagesFieldNumber = 1;
  inline const ::InstantMessage& syncmessages(int index) const;
  inline ::InstantMessage* mutable_syncmessages(int index);
  inline ::InstantMessage* add_syncmessages();
  inline const ::cloopen_google::protobuf::RepeatedPtrField< ::InstantMessage >&
      syncmessages() const;
  inline ::cloopen_google::protobuf::RepeatedPtrField< ::InstantMessage >*
      mutable_syncmessages();

  // @@protoc_insertion_point(class_scope:SyncMsgRespInner)
 private:

  ::std::string _unknown_fields_;

  ::cloopen_google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cloopen_google::protobuf::RepeatedPtrField< ::InstantMessage > syncmessages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SyncMsgResp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SyncMsgResp_2eproto();
  #endif
  friend void protobuf_AssignDesc_SyncMsgResp_2eproto();
  friend void protobuf_ShutdownFile_SyncMsgResp_2eproto();

  void InitAsDefaultInstance();
  static SyncMsgRespInner* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage : public ::cloopen_google::protobuf::MessageLite {
 public:
  InstantMessage();
  virtual ~InstantMessage();

  InstantMessage(const InstantMessage& from);

  inline InstantMessage& operator=(const InstantMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage* other);

  // implements Message ----------------------------------------------

  InstantMessage* New() const;
  void CheckTypeAndMergeFrom(const ::cloopen_google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage& from);
  void MergeFrom(const InstantMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::cloopen_google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::cloopen_google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::cloopen_google::protobuf::uint64 version() const;
  inline void set_version(::cloopen_google::protobuf::uint64 value);

  // optional uint32 msgType = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  inline ::cloopen_google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::cloopen_google::protobuf::uint32 value);

  // optional string msgId = 3;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 3;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // optional bytes msgContent = 4;
  inline bool has_msgcontent() const;
  inline void clear_msgcontent();
  static const int kMsgContentFieldNumber = 4;
  inline const ::std::string& msgcontent() const;
  inline void set_msgcontent(const ::std::string& value);
  inline void set_msgcontent(const char* value);
  inline void set_msgcontent(const void* value, size_t size);
  inline ::std::string* mutable_msgcontent();
  inline ::std::string* release_msgcontent();
  inline void set_allocated_msgcontent(::std::string* msgcontent);

  // optional string msgSender = 5;
  inline bool has_msgsender() const;
  inline void clear_msgsender();
  static const int kMsgSenderFieldNumber = 5;
  inline const ::std::string& msgsender() const;
  inline void set_msgsender(const ::std::string& value);
  inline void set_msgsender(const char* value);
  inline void set_msgsender(const char* value, size_t size);
  inline ::std::string* mutable_msgsender();
  inline ::std::string* release_msgsender();
  inline void set_allocated_msgsender(::std::string* msgsender);

  // optional string msgReceiver = 6;
  inline bool has_msgreceiver() const;
  inline void clear_msgreceiver();
  static const int kMsgReceiverFieldNumber = 6;
  inline const ::std::string& msgreceiver() const;
  inline void set_msgreceiver(const ::std::string& value);
  inline void set_msgreceiver(const char* value);
  inline void set_msgreceiver(const char* value, size_t size);
  inline ::std::string* mutable_msgreceiver();
  inline ::std::string* release_msgreceiver();
  inline void set_allocated_msgreceiver(::std::string* msgreceiver);

  // optional string msgDomain = 7;
  inline bool has_msgdomain() const;
  inline void clear_msgdomain();
  static const int kMsgDomainFieldNumber = 7;
  inline const ::std::string& msgdomain() const;
  inline void set_msgdomain(const ::std::string& value);
  inline void set_msgdomain(const char* value);
  inline void set_msgdomain(const char* value, size_t size);
  inline ::std::string* mutable_msgdomain();
  inline ::std::string* release_msgdomain();
  inline void set_allocated_msgdomain(::std::string* msgdomain);

  // optional string msgFileName = 8;
  inline bool has_msgfilename() const;
  inline void clear_msgfilename();
  static const int kMsgFileNameFieldNumber = 8;
  inline const ::std::string& msgfilename() const;
  inline void set_msgfilename(const ::std::string& value);
  inline void set_msgfilename(const char* value);
  inline void set_msgfilename(const char* value, size_t size);
  inline ::std::string* mutable_msgfilename();
  inline ::std::string* release_msgfilename();
  inline void set_allocated_msgfilename(::std::string* msgfilename);

  // optional string msgFileUrl = 9;
  inline bool has_msgfileurl() const;
  inline void clear_msgfileurl();
  static const int kMsgFileUrlFieldNumber = 9;
  inline const ::std::string& msgfileurl() const;
  inline void set_msgfileurl(const ::std::string& value);
  inline void set_msgfileurl(const char* value);
  inline void set_msgfileurl(const char* value, size_t size);
  inline ::std::string* mutable_msgfileurl();
  inline ::std::string* release_msgfileurl();
  inline void set_allocated_msgfileurl(::std::string* msgfileurl);

  // optional string msgDateCreated = 10;
  inline bool has_msgdatecreated() const;
  inline void clear_msgdatecreated();
  static const int kMsgDateCreatedFieldNumber = 10;
  inline const ::std::string& msgdatecreated() const;
  inline void set_msgdatecreated(const ::std::string& value);
  inline void set_msgdatecreated(const char* value);
  inline void set_msgdatecreated(const char* value, size_t size);
  inline ::std::string* mutable_msgdatecreated();
  inline ::std::string* release_msgdatecreated();
  inline void set_allocated_msgdatecreated(::std::string* msgdatecreated);

  // optional uint32 msgCompressLen = 11;
  inline bool has_msgcompresslen() const;
  inline void clear_msgcompresslen();
  static const int kMsgCompressLenFieldNumber = 11;
  inline ::cloopen_google::protobuf::uint32 msgcompresslen() const;
  inline void set_msgcompresslen(::cloopen_google::protobuf::uint32 value);

  // optional bytes msgData = 12;
  inline bool has_msgdata() const;
  inline void clear_msgdata();
  static const int kMsgDataFieldNumber = 12;
  inline const ::std::string& msgdata() const;
  inline void set_msgdata(const ::std::string& value);
  inline void set_msgdata(const char* value);
  inline void set_msgdata(const void* value, size_t size);
  inline ::std::string* mutable_msgdata();
  inline ::std::string* release_msgdata();
  inline void set_allocated_msgdata(::std::string* msgdata);

  // optional uint32 mcmEvent = 13;
  inline bool has_mcmevent() const;
  inline void clear_mcmevent();
  static const int kMcmEventFieldNumber = 13;
  inline ::cloopen_google::protobuf::uint32 mcmevent() const;
  inline void set_mcmevent(::cloopen_google::protobuf::uint32 value);

  // optional string msgFileSize = 14;
  inline bool has_msgfilesize() const;
  inline void clear_msgfilesize();
  static const int kMsgFileSizeFieldNumber = 14;
  inline const ::std::string& msgfilesize() const;
  inline void set_msgfilesize(const ::std::string& value);
  inline void set_msgfilesize(const char* value);
  inline void set_msgfilesize(const char* value, size_t size);
  inline ::std::string* mutable_msgfilesize();
  inline ::std::string* release_msgfilesize();
  inline void set_allocated_msgfilesize(::std::string* msgfilesize);

  // optional string extOpts = 15;
  inline bool has_extopts() const;
  inline void clear_extopts();
  static const int kExtOptsFieldNumber = 15;
  inline const ::std::string& extopts() const;
  inline void set_extopts(const ::std::string& value);
  inline void set_extopts(const char* value);
  inline void set_extopts(const char* value, size_t size);
  inline ::std::string* mutable_extopts();
  inline ::std::string* release_extopts();
  inline void set_allocated_extopts(::std::string* extopts);

  // optional string senderNickName = 16;
  inline bool has_sendernickname() const;
  inline void clear_sendernickname();
  static const int kSenderNickNameFieldNumber = 16;
  inline const ::std::string& sendernickname() const;
  inline void set_sendernickname(const ::std::string& value);
  inline void set_sendernickname(const char* value);
  inline void set_sendernickname(const char* value, size_t size);
  inline ::std::string* mutable_sendernickname();
  inline ::std::string* release_sendernickname();
  inline void set_allocated_sendernickname(::std::string* sendernickname);

  // @@protoc_insertion_point(class_scope:InstantMessage)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_msgcontent();
  inline void clear_has_msgcontent();
  inline void set_has_msgsender();
  inline void clear_has_msgsender();
  inline void set_has_msgreceiver();
  inline void clear_has_msgreceiver();
  inline void set_has_msgdomain();
  inline void clear_has_msgdomain();
  inline void set_has_msgfilename();
  inline void clear_has_msgfilename();
  inline void set_has_msgfileurl();
  inline void clear_has_msgfileurl();
  inline void set_has_msgdatecreated();
  inline void clear_has_msgdatecreated();
  inline void set_has_msgcompresslen();
  inline void clear_has_msgcompresslen();
  inline void set_has_msgdata();
  inline void clear_has_msgdata();
  inline void set_has_mcmevent();
  inline void clear_has_mcmevent();
  inline void set_has_msgfilesize();
  inline void clear_has_msgfilesize();
  inline void set_has_extopts();
  inline void clear_has_extopts();
  inline void set_has_sendernickname();
  inline void clear_has_sendernickname();

  ::std::string _unknown_fields_;

  ::cloopen_google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cloopen_google::protobuf::uint64 version_;
  ::std::string* msgid_;
  ::std::string* msgcontent_;
  ::std::string* msgsender_;
  ::std::string* msgreceiver_;
  ::cloopen_google::protobuf::uint32 msgtype_;
  ::cloopen_google::protobuf::uint32 msgcompresslen_;
  ::std::string* msgdomain_;
  ::std::string* msgfilename_;
  ::std::string* msgfileurl_;
  ::std::string* msgdatecreated_;
  ::std::string* msgdata_;
  ::std::string* msgfilesize_;
  ::std::string* extopts_;
  ::std::string* sendernickname_;
  ::cloopen_google::protobuf::uint32 mcmevent_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SyncMsgResp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SyncMsgResp_2eproto();
  #endif
  friend void protobuf_AssignDesc_SyncMsgResp_2eproto();
  friend void protobuf_ShutdownFile_SyncMsgResp_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// SyncMsgRespInner

// repeated .InstantMessage syncMessages = 1;
inline int SyncMsgRespInner::syncmessages_size() const {
  return syncmessages_.size();
}
inline void SyncMsgRespInner::clear_syncmessages() {
  syncmessages_.Clear();
}
inline const ::InstantMessage& SyncMsgRespInner::syncmessages(int index) const {
  // @@protoc_insertion_point(field_get:SyncMsgRespInner.syncMessages)
  return syncmessages_.Get(index);
}
inline ::InstantMessage* SyncMsgRespInner::mutable_syncmessages(int index) {
  // @@protoc_insertion_point(field_mutable:SyncMsgRespInner.syncMessages)
  return syncmessages_.Mutable(index);
}
inline ::InstantMessage* SyncMsgRespInner::add_syncmessages() {
  // @@protoc_insertion_point(field_add:SyncMsgRespInner.syncMessages)
  return syncmessages_.Add();
}
inline const ::cloopen_google::protobuf::RepeatedPtrField< ::InstantMessage >&
SyncMsgRespInner::syncmessages() const {
  // @@protoc_insertion_point(field_list:SyncMsgRespInner.syncMessages)
  return syncmessages_;
}
inline ::cloopen_google::protobuf::RepeatedPtrField< ::InstantMessage >*
SyncMsgRespInner::mutable_syncmessages() {
  // @@protoc_insertion_point(field_mutable_list:SyncMsgRespInner.syncMessages)
  return &syncmessages_;
}

// -------------------------------------------------------------------

// InstantMessage

// optional uint64 version = 1;
inline bool InstantMessage::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::cloopen_google::protobuf::uint64 InstantMessage::version() const {
  // @@protoc_insertion_point(field_get:InstantMessage.version)
  return version_;
}
inline void InstantMessage::set_version(::cloopen_google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:InstantMessage.version)
}

// optional uint32 msgType = 2;
inline bool InstantMessage::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstantMessage::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstantMessage::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstantMessage::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::cloopen_google::protobuf::uint32 InstantMessage::msgtype() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgType)
  return msgtype_;
}
inline void InstantMessage::set_msgtype(::cloopen_google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:InstantMessage.msgType)
}

// optional string msgId = 3;
inline bool InstantMessage::has_msgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstantMessage::set_has_msgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstantMessage::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstantMessage::clear_msgid() {
  if (msgid_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& InstantMessage::msgid() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgId)
  return *msgid_;
}
inline void InstantMessage::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgId)
}
inline void InstantMessage::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgId)
}
inline void InstantMessage::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgId)
}
inline ::std::string* InstantMessage::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgId)
  return msgid_;
}
inline ::std::string* InstantMessage::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgId)
}

// optional bytes msgContent = 4;
inline bool InstantMessage::has_msgcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstantMessage::set_has_msgcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstantMessage::clear_has_msgcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstantMessage::clear_msgcontent() {
  if (msgcontent_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgcontent_->clear();
  }
  clear_has_msgcontent();
}
inline const ::std::string& InstantMessage::msgcontent() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgContent)
  return *msgcontent_;
}
inline void InstantMessage::set_msgcontent(const ::std::string& value) {
  set_has_msgcontent();
  if (msgcontent_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgContent)
}
inline void InstantMessage::set_msgcontent(const char* value) {
  set_has_msgcontent();
  if (msgcontent_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgContent)
}
inline void InstantMessage::set_msgcontent(const void* value, size_t size) {
  set_has_msgcontent();
  if (msgcontent_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgContent)
}
inline ::std::string* InstantMessage::mutable_msgcontent() {
  set_has_msgcontent();
  if (msgcontent_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgcontent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgContent)
  return msgcontent_;
}
inline ::std::string* InstantMessage::release_msgcontent() {
  clear_has_msgcontent();
  if (msgcontent_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgcontent_;
    msgcontent_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgcontent(::std::string* msgcontent) {
  if (msgcontent_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgcontent_;
  }
  if (msgcontent) {
    set_has_msgcontent();
    msgcontent_ = msgcontent;
  } else {
    clear_has_msgcontent();
    msgcontent_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgContent)
}

// optional string msgSender = 5;
inline bool InstantMessage::has_msgsender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstantMessage::set_has_msgsender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstantMessage::clear_has_msgsender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstantMessage::clear_msgsender() {
  if (msgsender_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgsender_->clear();
  }
  clear_has_msgsender();
}
inline const ::std::string& InstantMessage::msgsender() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgSender)
  return *msgsender_;
}
inline void InstantMessage::set_msgsender(const ::std::string& value) {
  set_has_msgsender();
  if (msgsender_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgsender_ = new ::std::string;
  }
  msgsender_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgSender)
}
inline void InstantMessage::set_msgsender(const char* value) {
  set_has_msgsender();
  if (msgsender_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgsender_ = new ::std::string;
  }
  msgsender_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgSender)
}
inline void InstantMessage::set_msgsender(const char* value, size_t size) {
  set_has_msgsender();
  if (msgsender_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgsender_ = new ::std::string;
  }
  msgsender_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgSender)
}
inline ::std::string* InstantMessage::mutable_msgsender() {
  set_has_msgsender();
  if (msgsender_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgsender_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgSender)
  return msgsender_;
}
inline ::std::string* InstantMessage::release_msgsender() {
  clear_has_msgsender();
  if (msgsender_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgsender_;
    msgsender_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgsender(::std::string* msgsender) {
  if (msgsender_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgsender_;
  }
  if (msgsender) {
    set_has_msgsender();
    msgsender_ = msgsender;
  } else {
    clear_has_msgsender();
    msgsender_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgSender)
}

// optional string msgReceiver = 6;
inline bool InstantMessage::has_msgreceiver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstantMessage::set_has_msgreceiver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstantMessage::clear_has_msgreceiver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstantMessage::clear_msgreceiver() {
  if (msgreceiver_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgreceiver_->clear();
  }
  clear_has_msgreceiver();
}
inline const ::std::string& InstantMessage::msgreceiver() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgReceiver)
  return *msgreceiver_;
}
inline void InstantMessage::set_msgreceiver(const ::std::string& value) {
  set_has_msgreceiver();
  if (msgreceiver_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgreceiver_ = new ::std::string;
  }
  msgreceiver_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgReceiver)
}
inline void InstantMessage::set_msgreceiver(const char* value) {
  set_has_msgreceiver();
  if (msgreceiver_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgreceiver_ = new ::std::string;
  }
  msgreceiver_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgReceiver)
}
inline void InstantMessage::set_msgreceiver(const char* value, size_t size) {
  set_has_msgreceiver();
  if (msgreceiver_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgreceiver_ = new ::std::string;
  }
  msgreceiver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgReceiver)
}
inline ::std::string* InstantMessage::mutable_msgreceiver() {
  set_has_msgreceiver();
  if (msgreceiver_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgreceiver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgReceiver)
  return msgreceiver_;
}
inline ::std::string* InstantMessage::release_msgreceiver() {
  clear_has_msgreceiver();
  if (msgreceiver_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgreceiver_;
    msgreceiver_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgreceiver(::std::string* msgreceiver) {
  if (msgreceiver_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgreceiver_;
  }
  if (msgreceiver) {
    set_has_msgreceiver();
    msgreceiver_ = msgreceiver;
  } else {
    clear_has_msgreceiver();
    msgreceiver_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgReceiver)
}

// optional string msgDomain = 7;
inline bool InstantMessage::has_msgdomain() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstantMessage::set_has_msgdomain() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstantMessage::clear_has_msgdomain() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstantMessage::clear_msgdomain() {
  if (msgdomain_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdomain_->clear();
  }
  clear_has_msgdomain();
}
inline const ::std::string& InstantMessage::msgdomain() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgDomain)
  return *msgdomain_;
}
inline void InstantMessage::set_msgdomain(const ::std::string& value) {
  set_has_msgdomain();
  if (msgdomain_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdomain_ = new ::std::string;
  }
  msgdomain_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgDomain)
}
inline void InstantMessage::set_msgdomain(const char* value) {
  set_has_msgdomain();
  if (msgdomain_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdomain_ = new ::std::string;
  }
  msgdomain_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgDomain)
}
inline void InstantMessage::set_msgdomain(const char* value, size_t size) {
  set_has_msgdomain();
  if (msgdomain_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdomain_ = new ::std::string;
  }
  msgdomain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgDomain)
}
inline ::std::string* InstantMessage::mutable_msgdomain() {
  set_has_msgdomain();
  if (msgdomain_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdomain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgDomain)
  return msgdomain_;
}
inline ::std::string* InstantMessage::release_msgdomain() {
  clear_has_msgdomain();
  if (msgdomain_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgdomain_;
    msgdomain_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgdomain(::std::string* msgdomain) {
  if (msgdomain_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgdomain_;
  }
  if (msgdomain) {
    set_has_msgdomain();
    msgdomain_ = msgdomain;
  } else {
    clear_has_msgdomain();
    msgdomain_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgDomain)
}

// optional string msgFileName = 8;
inline bool InstantMessage::has_msgfilename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstantMessage::set_has_msgfilename() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstantMessage::clear_has_msgfilename() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstantMessage::clear_msgfilename() {
  if (msgfilename_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilename_->clear();
  }
  clear_has_msgfilename();
}
inline const ::std::string& InstantMessage::msgfilename() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgFileName)
  return *msgfilename_;
}
inline void InstantMessage::set_msgfilename(const ::std::string& value) {
  set_has_msgfilename();
  if (msgfilename_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilename_ = new ::std::string;
  }
  msgfilename_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgFileName)
}
inline void InstantMessage::set_msgfilename(const char* value) {
  set_has_msgfilename();
  if (msgfilename_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilename_ = new ::std::string;
  }
  msgfilename_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgFileName)
}
inline void InstantMessage::set_msgfilename(const char* value, size_t size) {
  set_has_msgfilename();
  if (msgfilename_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilename_ = new ::std::string;
  }
  msgfilename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgFileName)
}
inline ::std::string* InstantMessage::mutable_msgfilename() {
  set_has_msgfilename();
  if (msgfilename_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgFileName)
  return msgfilename_;
}
inline ::std::string* InstantMessage::release_msgfilename() {
  clear_has_msgfilename();
  if (msgfilename_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgfilename_;
    msgfilename_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgfilename(::std::string* msgfilename) {
  if (msgfilename_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgfilename_;
  }
  if (msgfilename) {
    set_has_msgfilename();
    msgfilename_ = msgfilename;
  } else {
    clear_has_msgfilename();
    msgfilename_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgFileName)
}

// optional string msgFileUrl = 9;
inline bool InstantMessage::has_msgfileurl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstantMessage::set_has_msgfileurl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstantMessage::clear_has_msgfileurl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstantMessage::clear_msgfileurl() {
  if (msgfileurl_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfileurl_->clear();
  }
  clear_has_msgfileurl();
}
inline const ::std::string& InstantMessage::msgfileurl() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgFileUrl)
  return *msgfileurl_;
}
inline void InstantMessage::set_msgfileurl(const ::std::string& value) {
  set_has_msgfileurl();
  if (msgfileurl_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfileurl_ = new ::std::string;
  }
  msgfileurl_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgFileUrl)
}
inline void InstantMessage::set_msgfileurl(const char* value) {
  set_has_msgfileurl();
  if (msgfileurl_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfileurl_ = new ::std::string;
  }
  msgfileurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgFileUrl)
}
inline void InstantMessage::set_msgfileurl(const char* value, size_t size) {
  set_has_msgfileurl();
  if (msgfileurl_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfileurl_ = new ::std::string;
  }
  msgfileurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgFileUrl)
}
inline ::std::string* InstantMessage::mutable_msgfileurl() {
  set_has_msgfileurl();
  if (msgfileurl_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfileurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgFileUrl)
  return msgfileurl_;
}
inline ::std::string* InstantMessage::release_msgfileurl() {
  clear_has_msgfileurl();
  if (msgfileurl_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgfileurl_;
    msgfileurl_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgfileurl(::std::string* msgfileurl) {
  if (msgfileurl_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgfileurl_;
  }
  if (msgfileurl) {
    set_has_msgfileurl();
    msgfileurl_ = msgfileurl;
  } else {
    clear_has_msgfileurl();
    msgfileurl_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgFileUrl)
}

// optional string msgDateCreated = 10;
inline bool InstantMessage::has_msgdatecreated() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstantMessage::set_has_msgdatecreated() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstantMessage::clear_has_msgdatecreated() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstantMessage::clear_msgdatecreated() {
  if (msgdatecreated_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdatecreated_->clear();
  }
  clear_has_msgdatecreated();
}
inline const ::std::string& InstantMessage::msgdatecreated() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgDateCreated)
  return *msgdatecreated_;
}
inline void InstantMessage::set_msgdatecreated(const ::std::string& value) {
  set_has_msgdatecreated();
  if (msgdatecreated_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdatecreated_ = new ::std::string;
  }
  msgdatecreated_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgDateCreated)
}
inline void InstantMessage::set_msgdatecreated(const char* value) {
  set_has_msgdatecreated();
  if (msgdatecreated_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdatecreated_ = new ::std::string;
  }
  msgdatecreated_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgDateCreated)
}
inline void InstantMessage::set_msgdatecreated(const char* value, size_t size) {
  set_has_msgdatecreated();
  if (msgdatecreated_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdatecreated_ = new ::std::string;
  }
  msgdatecreated_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgDateCreated)
}
inline ::std::string* InstantMessage::mutable_msgdatecreated() {
  set_has_msgdatecreated();
  if (msgdatecreated_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdatecreated_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgDateCreated)
  return msgdatecreated_;
}
inline ::std::string* InstantMessage::release_msgdatecreated() {
  clear_has_msgdatecreated();
  if (msgdatecreated_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgdatecreated_;
    msgdatecreated_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgdatecreated(::std::string* msgdatecreated) {
  if (msgdatecreated_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgdatecreated_;
  }
  if (msgdatecreated) {
    set_has_msgdatecreated();
    msgdatecreated_ = msgdatecreated;
  } else {
    clear_has_msgdatecreated();
    msgdatecreated_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgDateCreated)
}

// optional uint32 msgCompressLen = 11;
inline bool InstantMessage::has_msgcompresslen() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstantMessage::set_has_msgcompresslen() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstantMessage::clear_has_msgcompresslen() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstantMessage::clear_msgcompresslen() {
  msgcompresslen_ = 0u;
  clear_has_msgcompresslen();
}
inline ::cloopen_google::protobuf::uint32 InstantMessage::msgcompresslen() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgCompressLen)
  return msgcompresslen_;
}
inline void InstantMessage::set_msgcompresslen(::cloopen_google::protobuf::uint32 value) {
  set_has_msgcompresslen();
  msgcompresslen_ = value;
  // @@protoc_insertion_point(field_set:InstantMessage.msgCompressLen)
}

// optional bytes msgData = 12;
inline bool InstantMessage::has_msgdata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstantMessage::set_has_msgdata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstantMessage::clear_has_msgdata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstantMessage::clear_msgdata() {
  if (msgdata_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdata_->clear();
  }
  clear_has_msgdata();
}
inline const ::std::string& InstantMessage::msgdata() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgData)
  return *msgdata_;
}
inline void InstantMessage::set_msgdata(const ::std::string& value) {
  set_has_msgdata();
  if (msgdata_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdata_ = new ::std::string;
  }
  msgdata_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgData)
}
inline void InstantMessage::set_msgdata(const char* value) {
  set_has_msgdata();
  if (msgdata_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdata_ = new ::std::string;
  }
  msgdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgData)
}
inline void InstantMessage::set_msgdata(const void* value, size_t size) {
  set_has_msgdata();
  if (msgdata_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdata_ = new ::std::string;
  }
  msgdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgData)
}
inline ::std::string* InstantMessage::mutable_msgdata() {
  set_has_msgdata();
  if (msgdata_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgData)
  return msgdata_;
}
inline ::std::string* InstantMessage::release_msgdata() {
  clear_has_msgdata();
  if (msgdata_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgdata_;
    msgdata_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgdata(::std::string* msgdata) {
  if (msgdata_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgdata_;
  }
  if (msgdata) {
    set_has_msgdata();
    msgdata_ = msgdata;
  } else {
    clear_has_msgdata();
    msgdata_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgData)
}

// optional uint32 mcmEvent = 13;
inline bool InstantMessage::has_mcmevent() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstantMessage::set_has_mcmevent() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstantMessage::clear_has_mcmevent() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstantMessage::clear_mcmevent() {
  mcmevent_ = 0u;
  clear_has_mcmevent();
}
inline ::cloopen_google::protobuf::uint32 InstantMessage::mcmevent() const {
  // @@protoc_insertion_point(field_get:InstantMessage.mcmEvent)
  return mcmevent_;
}
inline void InstantMessage::set_mcmevent(::cloopen_google::protobuf::uint32 value) {
  set_has_mcmevent();
  mcmevent_ = value;
  // @@protoc_insertion_point(field_set:InstantMessage.mcmEvent)
}

// optional string msgFileSize = 14;
inline bool InstantMessage::has_msgfilesize() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstantMessage::set_has_msgfilesize() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstantMessage::clear_has_msgfilesize() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstantMessage::clear_msgfilesize() {
  if (msgfilesize_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilesize_->clear();
  }
  clear_has_msgfilesize();
}
inline const ::std::string& InstantMessage::msgfilesize() const {
  // @@protoc_insertion_point(field_get:InstantMessage.msgFileSize)
  return *msgfilesize_;
}
inline void InstantMessage::set_msgfilesize(const ::std::string& value) {
  set_has_msgfilesize();
  if (msgfilesize_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilesize_ = new ::std::string;
  }
  msgfilesize_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.msgFileSize)
}
inline void InstantMessage::set_msgfilesize(const char* value) {
  set_has_msgfilesize();
  if (msgfilesize_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilesize_ = new ::std::string;
  }
  msgfilesize_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.msgFileSize)
}
inline void InstantMessage::set_msgfilesize(const char* value, size_t size) {
  set_has_msgfilesize();
  if (msgfilesize_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilesize_ = new ::std::string;
  }
  msgfilesize_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.msgFileSize)
}
inline ::std::string* InstantMessage::mutable_msgfilesize() {
  set_has_msgfilesize();
  if (msgfilesize_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgfilesize_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.msgFileSize)
  return msgfilesize_;
}
inline ::std::string* InstantMessage::release_msgfilesize() {
  clear_has_msgfilesize();
  if (msgfilesize_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgfilesize_;
    msgfilesize_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_msgfilesize(::std::string* msgfilesize) {
  if (msgfilesize_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgfilesize_;
  }
  if (msgfilesize) {
    set_has_msgfilesize();
    msgfilesize_ = msgfilesize;
  } else {
    clear_has_msgfilesize();
    msgfilesize_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.msgFileSize)
}

// optional string extOpts = 15;
inline bool InstantMessage::has_extopts() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstantMessage::set_has_extopts() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstantMessage::clear_has_extopts() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstantMessage::clear_extopts() {
  if (extopts_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extopts_->clear();
  }
  clear_has_extopts();
}
inline const ::std::string& InstantMessage::extopts() const {
  // @@protoc_insertion_point(field_get:InstantMessage.extOpts)
  return *extopts_;
}
inline void InstantMessage::set_extopts(const ::std::string& value) {
  set_has_extopts();
  if (extopts_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extopts_ = new ::std::string;
  }
  extopts_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.extOpts)
}
inline void InstantMessage::set_extopts(const char* value) {
  set_has_extopts();
  if (extopts_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extopts_ = new ::std::string;
  }
  extopts_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.extOpts)
}
inline void InstantMessage::set_extopts(const char* value, size_t size) {
  set_has_extopts();
  if (extopts_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extopts_ = new ::std::string;
  }
  extopts_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.extOpts)
}
inline ::std::string* InstantMessage::mutable_extopts() {
  set_has_extopts();
  if (extopts_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extopts_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.extOpts)
  return extopts_;
}
inline ::std::string* InstantMessage::release_extopts() {
  clear_has_extopts();
  if (extopts_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extopts_;
    extopts_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_extopts(::std::string* extopts) {
  if (extopts_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extopts_;
  }
  if (extopts) {
    set_has_extopts();
    extopts_ = extopts;
  } else {
    clear_has_extopts();
    extopts_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.extOpts)
}

// optional string senderNickName = 16;
inline bool InstantMessage::has_sendernickname() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InstantMessage::set_has_sendernickname() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InstantMessage::clear_has_sendernickname() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InstantMessage::clear_sendernickname() {
  if (sendernickname_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendernickname_->clear();
  }
  clear_has_sendernickname();
}
inline const ::std::string& InstantMessage::sendernickname() const {
  // @@protoc_insertion_point(field_get:InstantMessage.senderNickName)
  return *sendernickname_;
}
inline void InstantMessage::set_sendernickname(const ::std::string& value) {
  set_has_sendernickname();
  if (sendernickname_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendernickname_ = new ::std::string;
  }
  sendernickname_->assign(value);
  // @@protoc_insertion_point(field_set:InstantMessage.senderNickName)
}
inline void InstantMessage::set_sendernickname(const char* value) {
  set_has_sendernickname();
  if (sendernickname_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendernickname_ = new ::std::string;
  }
  sendernickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:InstantMessage.senderNickName)
}
inline void InstantMessage::set_sendernickname(const char* value, size_t size) {
  set_has_sendernickname();
  if (sendernickname_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendernickname_ = new ::std::string;
  }
  sendernickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InstantMessage.senderNickName)
}
inline ::std::string* InstantMessage::mutable_sendernickname() {
  set_has_sendernickname();
  if (sendernickname_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendernickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:InstantMessage.senderNickName)
  return sendernickname_;
}
inline ::std::string* InstantMessage::release_sendernickname() {
  clear_has_sendernickname();
  if (sendernickname_ == &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sendernickname_;
    sendernickname_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage::set_allocated_sendernickname(::std::string* sendernickname) {
  if (sendernickname_ != &::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sendernickname_;
  }
  if (sendernickname) {
    set_has_sendernickname();
    sendernickname_ = sendernickname;
  } else {
    clear_has_sendernickname();
    sendernickname_ = const_cast< ::std::string*>(&::cloopen_google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:InstantMessage.senderNickName)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SyncMsgResp_2eproto__INCLUDED
