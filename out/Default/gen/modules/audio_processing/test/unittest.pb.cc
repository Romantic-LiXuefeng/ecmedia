// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unittest.proto

#include "unittest.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_unittest_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_unittest_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Test_DelayMetrics;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_unittest_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Test_EchoMetrics;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_unittest_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Test_Frame;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_unittest_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_Test;
}  // namespace protobuf_unittest_2eproto
namespace webrtc {
namespace audioproc {
class Test_FrameDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Test_Frame>
      _instance;
} _Test_Frame_default_instance_;
class Test_EchoMetricsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Test_EchoMetrics>
      _instance;
} _Test_EchoMetrics_default_instance_;
class Test_DelayMetricsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Test_DelayMetrics>
      _instance;
} _Test_DelayMetrics_default_instance_;
class TestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Test>
      _instance;
} _Test_default_instance_;
class OutputDataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<OutputData>
      _instance;
} _OutputData_default_instance_;
}  // namespace audioproc
}  // namespace webrtc
namespace protobuf_unittest_2eproto {
static void InitDefaultsTest_Frame() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::webrtc::audioproc::_Test_Frame_default_instance_;
    new (ptr) ::webrtc::audioproc::Test_Frame();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::webrtc::audioproc::Test_Frame::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Test_Frame =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTest_Frame}, {}};

static void InitDefaultsTest_EchoMetrics() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::webrtc::audioproc::_Test_EchoMetrics_default_instance_;
    new (ptr) ::webrtc::audioproc::Test_EchoMetrics();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::webrtc::audioproc::Test_EchoMetrics::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Test_EchoMetrics =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTest_EchoMetrics}, {}};

static void InitDefaultsTest_DelayMetrics() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::webrtc::audioproc::_Test_DelayMetrics_default_instance_;
    new (ptr) ::webrtc::audioproc::Test_DelayMetrics();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::webrtc::audioproc::Test_DelayMetrics::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Test_DelayMetrics =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTest_DelayMetrics}, {}};

static void InitDefaultsTest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::webrtc::audioproc::_Test_default_instance_;
    new (ptr) ::webrtc::audioproc::Test();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::webrtc::audioproc::Test::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_Test =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsTest}, {
      &protobuf_unittest_2eproto::scc_info_Test_Frame.base,
      &protobuf_unittest_2eproto::scc_info_Test_EchoMetrics.base,
      &protobuf_unittest_2eproto::scc_info_Test_DelayMetrics.base,}};

static void InitDefaultsOutputData() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::webrtc::audioproc::_OutputData_default_instance_;
    new (ptr) ::webrtc::audioproc::OutputData();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::webrtc::audioproc::OutputData::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_OutputData =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsOutputData}, {
      &protobuf_unittest_2eproto::scc_info_Test.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_Test_Frame.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Test_EchoMetrics.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Test_DelayMetrics.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Test.base);
  ::google::protobuf::internal::InitSCC(&scc_info_OutputData.base);
}

}  // namespace protobuf_unittest_2eproto
namespace webrtc {
namespace audioproc {

// ===================================================================

void Test_Frame::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_Frame::Test_Frame()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_unittest_2eproto::scc_info_Test_Frame.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.Frame)
}
Test_Frame::Test_Frame(const Test_Frame& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.Frame)
}

void Test_Frame::SharedCtor() {
}

Test_Frame::~Test_Frame() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.Frame)
  SharedDtor();
}

void Test_Frame::SharedDtor() {
}

void Test_Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Test_Frame& Test_Frame::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_unittest_2eproto::scc_info_Test_Frame.base);
  return *internal_default_instance();
}


void Test_Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.Frame)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Test_Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.Frame)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.Frame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.Frame)
  return false;
#undef DO_
}

void Test_Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.Frame)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.Frame)
}

size_t Test_Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.Frame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Test_Frame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_Frame*>(&from));
}

void Test_Frame::MergeFrom(const Test_Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.Frame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Test_Frame::CopyFrom(const Test_Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_Frame::IsInitialized() const {
  return true;
}

void Test_Frame::Swap(Test_Frame* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_Frame::InternalSwap(Test_Frame* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Test_Frame::GetTypeName() const {
  return "webrtc.audioproc.Test.Frame";
}


// ===================================================================

void Test_EchoMetrics::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test_EchoMetrics::kEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossEnhancementFieldNumber;
const int Test_EchoMetrics::kDivergentFilterFractionFieldNumber;
const int Test_EchoMetrics::kResidualEchoLikelihoodFieldNumber;
const int Test_EchoMetrics::kResidualEchoLikelihoodRecentMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_EchoMetrics::Test_EchoMetrics()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_unittest_2eproto::scc_info_Test_EchoMetrics.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.EchoMetrics)
}
Test_EchoMetrics::Test_EchoMetrics(const Test_EchoMetrics& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&echo_return_loss_, &from.echo_return_loss_,
    static_cast<size_t>(reinterpret_cast<char*>(&residual_echo_likelihood_recent_max_) -
    reinterpret_cast<char*>(&echo_return_loss_)) + sizeof(residual_echo_likelihood_recent_max_));
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.EchoMetrics)
}

void Test_EchoMetrics::SharedCtor() {
  ::memset(&echo_return_loss_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&residual_echo_likelihood_recent_max_) -
      reinterpret_cast<char*>(&echo_return_loss_)) + sizeof(residual_echo_likelihood_recent_max_));
}

Test_EchoMetrics::~Test_EchoMetrics() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.EchoMetrics)
  SharedDtor();
}

void Test_EchoMetrics::SharedDtor() {
}

void Test_EchoMetrics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Test_EchoMetrics& Test_EchoMetrics::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_unittest_2eproto::scc_info_Test_EchoMetrics.base);
  return *internal_default_instance();
}


void Test_EchoMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.EchoMetrics)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    ::memset(&echo_return_loss_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&residual_echo_likelihood_recent_max_) -
        reinterpret_cast<char*>(&echo_return_loss_)) + sizeof(residual_echo_likelihood_recent_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Test_EchoMetrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.EchoMetrics)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float echo_return_loss = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u /* 13 & 0xFF */)) {
          set_has_echo_return_loss();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &echo_return_loss_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float echo_return_loss_enhancement = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {
          set_has_echo_return_loss_enhancement();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &echo_return_loss_enhancement_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float divergent_filter_fraction = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {
          set_has_divergent_filter_fraction();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &divergent_filter_fraction_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float residual_echo_likelihood = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u /* 37 & 0xFF */)) {
          set_has_residual_echo_likelihood();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &residual_echo_likelihood_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float residual_echo_likelihood_recent_max = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u /* 45 & 0xFF */)) {
          set_has_residual_echo_likelihood_recent_max();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &residual_echo_likelihood_recent_max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.EchoMetrics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.EchoMetrics)
  return false;
#undef DO_
}

void Test_EchoMetrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.EchoMetrics)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float echo_return_loss = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->echo_return_loss(), output);
  }

  // optional float echo_return_loss_enhancement = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->echo_return_loss_enhancement(), output);
  }

  // optional float divergent_filter_fraction = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->divergent_filter_fraction(), output);
  }

  // optional float residual_echo_likelihood = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->residual_echo_likelihood(), output);
  }

  // optional float residual_echo_likelihood_recent_max = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->residual_echo_likelihood_recent_max(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.EchoMetrics)
}

size_t Test_EchoMetrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.EchoMetrics)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 31u) {
    // optional float echo_return_loss = 1;
    if (has_echo_return_loss()) {
      total_size += 1 + 4;
    }

    // optional float echo_return_loss_enhancement = 2;
    if (has_echo_return_loss_enhancement()) {
      total_size += 1 + 4;
    }

    // optional float divergent_filter_fraction = 3;
    if (has_divergent_filter_fraction()) {
      total_size += 1 + 4;
    }

    // optional float residual_echo_likelihood = 4;
    if (has_residual_echo_likelihood()) {
      total_size += 1 + 4;
    }

    // optional float residual_echo_likelihood_recent_max = 5;
    if (has_residual_echo_likelihood_recent_max()) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Test_EchoMetrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_EchoMetrics*>(&from));
}

void Test_EchoMetrics::MergeFrom(const Test_EchoMetrics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.EchoMetrics)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      echo_return_loss_ = from.echo_return_loss_;
    }
    if (cached_has_bits & 0x00000002u) {
      echo_return_loss_enhancement_ = from.echo_return_loss_enhancement_;
    }
    if (cached_has_bits & 0x00000004u) {
      divergent_filter_fraction_ = from.divergent_filter_fraction_;
    }
    if (cached_has_bits & 0x00000008u) {
      residual_echo_likelihood_ = from.residual_echo_likelihood_;
    }
    if (cached_has_bits & 0x00000010u) {
      residual_echo_likelihood_recent_max_ = from.residual_echo_likelihood_recent_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Test_EchoMetrics::CopyFrom(const Test_EchoMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.EchoMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_EchoMetrics::IsInitialized() const {
  return true;
}

void Test_EchoMetrics::Swap(Test_EchoMetrics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_EchoMetrics::InternalSwap(Test_EchoMetrics* other) {
  using std::swap;
  swap(echo_return_loss_, other->echo_return_loss_);
  swap(echo_return_loss_enhancement_, other->echo_return_loss_enhancement_);
  swap(divergent_filter_fraction_, other->divergent_filter_fraction_);
  swap(residual_echo_likelihood_, other->residual_echo_likelihood_);
  swap(residual_echo_likelihood_recent_max_, other->residual_echo_likelihood_recent_max_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Test_EchoMetrics::GetTypeName() const {
  return "webrtc.audioproc.Test.EchoMetrics";
}


// ===================================================================

void Test_DelayMetrics::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test_DelayMetrics::kMedianFieldNumber;
const int Test_DelayMetrics::kStdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_DelayMetrics::Test_DelayMetrics()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_unittest_2eproto::scc_info_Test_DelayMetrics.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.DelayMetrics)
}
Test_DelayMetrics::Test_DelayMetrics(const Test_DelayMetrics& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&median_, &from.median_,
    static_cast<size_t>(reinterpret_cast<char*>(&std_) -
    reinterpret_cast<char*>(&median_)) + sizeof(std_));
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.DelayMetrics)
}

void Test_DelayMetrics::SharedCtor() {
  ::memset(&median_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&std_) -
      reinterpret_cast<char*>(&median_)) + sizeof(std_));
}

Test_DelayMetrics::~Test_DelayMetrics() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.DelayMetrics)
  SharedDtor();
}

void Test_DelayMetrics::SharedDtor() {
}

void Test_DelayMetrics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Test_DelayMetrics& Test_DelayMetrics::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_unittest_2eproto::scc_info_Test_DelayMetrics.base);
  return *internal_default_instance();
}


void Test_DelayMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.DelayMetrics)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&median_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&std_) -
        reinterpret_cast<char*>(&median_)) + sizeof(std_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Test_DelayMetrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.DelayMetrics)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 median = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_median();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &median_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 std = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_std();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &std_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.DelayMetrics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.DelayMetrics)
  return false;
#undef DO_
}

void Test_DelayMetrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.DelayMetrics)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 median = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->median(), output);
  }

  // optional int32 std = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->std(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.DelayMetrics)
}

size_t Test_DelayMetrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.DelayMetrics)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional int32 median = 1;
    if (has_median()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->median());
    }

    // optional int32 std = 2;
    if (has_std()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->std());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Test_DelayMetrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_DelayMetrics*>(&from));
}

void Test_DelayMetrics::MergeFrom(const Test_DelayMetrics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.DelayMetrics)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      median_ = from.median_;
    }
    if (cached_has_bits & 0x00000002u) {
      std_ = from.std_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Test_DelayMetrics::CopyFrom(const Test_DelayMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.DelayMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_DelayMetrics::IsInitialized() const {
  return true;
}

void Test_DelayMetrics::Swap(Test_DelayMetrics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_DelayMetrics::InternalSwap(Test_DelayMetrics* other) {
  using std::swap;
  swap(median_, other->median_);
  swap(std_, other->std_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Test_DelayMetrics::GetTypeName() const {
  return "webrtc.audioproc.Test.DelayMetrics";
}


// ===================================================================

void Test::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test::kNumReverseChannelsFieldNumber;
const int Test::kNumInputChannelsFieldNumber;
const int Test::kNumOutputChannelsFieldNumber;
const int Test::kSampleRateFieldNumber;
const int Test::kFrameFieldNumber;
const int Test::kAnalogLevelAverageFieldNumber;
const int Test::kMaxOutputAverageFieldNumber;
const int Test::kHasVoiceCountFieldNumber;
const int Test::kIsSaturatedCountFieldNumber;
const int Test::kEchoMetricsFieldNumber;
const int Test::kDelayMetricsFieldNumber;
const int Test::kRmsDbfsAverageFieldNumber;
const int Test::kNsSpeechProbabilityAverageFieldNumber;
const int Test::kUseAecExtendedFilterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test::Test()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_unittest_2eproto::scc_info_Test.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test)
}
Test::Test(const Test& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      frame_(from.frame_),
      echo_metrics_(from.echo_metrics_),
      delay_metrics_(from.delay_metrics_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&num_reverse_channels_, &from.num_reverse_channels_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_aec_extended_filter_) -
    reinterpret_cast<char*>(&num_reverse_channels_)) + sizeof(use_aec_extended_filter_));
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test)
}

void Test::SharedCtor() {
  ::memset(&num_reverse_channels_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&use_aec_extended_filter_) -
      reinterpret_cast<char*>(&num_reverse_channels_)) + sizeof(use_aec_extended_filter_));
}

Test::~Test() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test)
  SharedDtor();
}

void Test::SharedDtor() {
}

void Test::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Test& Test::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_unittest_2eproto::scc_info_Test.base);
  return *internal_default_instance();
}


void Test::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  frame_.Clear();
  echo_metrics_.Clear();
  delay_metrics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 255u) {
    ::memset(&num_reverse_channels_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_saturated_count_) -
        reinterpret_cast<char*>(&num_reverse_channels_)) + sizeof(is_saturated_count_));
  }
  if (cached_has_bits & 1792u) {
    ::memset(&rms_dbfs_average_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_aec_extended_filter_) -
        reinterpret_cast<char*>(&rms_dbfs_average_)) + sizeof(use_aec_extended_filter_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Test::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_reverse_channels = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_num_reverse_channels();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_reverse_channels_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_input_channels = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_num_input_channels();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_input_channels_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 num_output_channels = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_num_output_channels();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_output_channels_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 sample_rate = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_sample_rate();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sample_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .webrtc.audioproc.Test.Frame frame = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_frame()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 analog_level_average = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_analog_level_average();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &analog_level_average_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_output_average = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_max_output_average();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_output_average_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 has_voice_count = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_has_voice_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_voice_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 is_saturated_count = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_is_saturated_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_saturated_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_echo_metrics()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u /* 98 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_delay_metrics()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float rms_dbfs_average = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(109u /* 109 & 0xFF */)) {
          set_has_rms_dbfs_average();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rms_dbfs_average_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float ns_speech_probability_average = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(117u /* 117 & 0xFF */)) {
          set_has_ns_speech_probability_average();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ns_speech_probability_average_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_aec_extended_filter = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {
          set_has_use_aec_extended_filter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_aec_extended_filter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test)
  return false;
#undef DO_
}

void Test::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_reverse_channels = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num_reverse_channels(), output);
  }

  // optional int32 num_input_channels = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num_input_channels(), output);
  }

  // optional int32 num_output_channels = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_output_channels(), output);
  }

  // optional int32 sample_rate = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sample_rate(), output);
  }

  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->frame_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5,
      this->frame(static_cast<int>(i)),
      output);
  }

  // optional int32 analog_level_average = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->analog_level_average(), output);
  }

  // optional int32 max_output_average = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->max_output_average(), output);
  }

  // optional int32 has_voice_count = 9;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->has_voice_count(), output);
  }

  // optional int32 is_saturated_count = 10;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->is_saturated_count(), output);
  }

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->echo_metrics_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11,
      this->echo_metrics(static_cast<int>(i)),
      output);
  }

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->delay_metrics_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12,
      this->delay_metrics(static_cast<int>(i)),
      output);
  }

  // optional float rms_dbfs_average = 13;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->rms_dbfs_average(), output);
  }

  // optional float ns_speech_probability_average = 14;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->ns_speech_probability_average(), output);
  }

  // optional bool use_aec_extended_filter = 15;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->use_aec_extended_filter(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test)
}

size_t Test::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->frame_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->frame(static_cast<int>(i)));
    }
  }

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->echo_metrics_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->echo_metrics(static_cast<int>(i)));
    }
  }

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->delay_metrics_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->delay_metrics(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 255u) {
    // optional int32 num_reverse_channels = 1;
    if (has_num_reverse_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_reverse_channels());
    }

    // optional int32 num_input_channels = 2;
    if (has_num_input_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_input_channels());
    }

    // optional int32 num_output_channels = 3;
    if (has_num_output_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_output_channels());
    }

    // optional int32 sample_rate = 4;
    if (has_sample_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sample_rate());
    }

    // optional int32 analog_level_average = 6;
    if (has_analog_level_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->analog_level_average());
    }

    // optional int32 max_output_average = 7;
    if (has_max_output_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_output_average());
    }

    // optional int32 has_voice_count = 9;
    if (has_has_voice_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->has_voice_count());
    }

    // optional int32 is_saturated_count = 10;
    if (has_is_saturated_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_saturated_count());
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional float rms_dbfs_average = 13;
    if (has_rms_dbfs_average()) {
      total_size += 1 + 4;
    }

    // optional float ns_speech_probability_average = 14;
    if (has_ns_speech_probability_average()) {
      total_size += 1 + 4;
    }

    // optional bool use_aec_extended_filter = 15;
    if (has_use_aec_extended_filter()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Test::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test*>(&from));
}

void Test::MergeFrom(const Test& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  frame_.MergeFrom(from.frame_);
  echo_metrics_.MergeFrom(from.echo_metrics_);
  delay_metrics_.MergeFrom(from.delay_metrics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      num_reverse_channels_ = from.num_reverse_channels_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_input_channels_ = from.num_input_channels_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_output_channels_ = from.num_output_channels_;
    }
    if (cached_has_bits & 0x00000008u) {
      sample_rate_ = from.sample_rate_;
    }
    if (cached_has_bits & 0x00000010u) {
      analog_level_average_ = from.analog_level_average_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_output_average_ = from.max_output_average_;
    }
    if (cached_has_bits & 0x00000040u) {
      has_voice_count_ = from.has_voice_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_saturated_count_ = from.is_saturated_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 1792u) {
    if (cached_has_bits & 0x00000100u) {
      rms_dbfs_average_ = from.rms_dbfs_average_;
    }
    if (cached_has_bits & 0x00000200u) {
      ns_speech_probability_average_ = from.ns_speech_probability_average_;
    }
    if (cached_has_bits & 0x00000400u) {
      use_aec_extended_filter_ = from.use_aec_extended_filter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Test::CopyFrom(const Test& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test::IsInitialized() const {
  return true;
}

void Test::Swap(Test* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test::InternalSwap(Test* other) {
  using std::swap;
  CastToBase(&frame_)->InternalSwap(CastToBase(&other->frame_));
  CastToBase(&echo_metrics_)->InternalSwap(CastToBase(&other->echo_metrics_));
  CastToBase(&delay_metrics_)->InternalSwap(CastToBase(&other->delay_metrics_));
  swap(num_reverse_channels_, other->num_reverse_channels_);
  swap(num_input_channels_, other->num_input_channels_);
  swap(num_output_channels_, other->num_output_channels_);
  swap(sample_rate_, other->sample_rate_);
  swap(analog_level_average_, other->analog_level_average_);
  swap(max_output_average_, other->max_output_average_);
  swap(has_voice_count_, other->has_voice_count_);
  swap(is_saturated_count_, other->is_saturated_count_);
  swap(rms_dbfs_average_, other->rms_dbfs_average_);
  swap(ns_speech_probability_average_, other->ns_speech_probability_average_);
  swap(use_aec_extended_filter_, other->use_aec_extended_filter_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string Test::GetTypeName() const {
  return "webrtc.audioproc.Test";
}


// ===================================================================

void OutputData::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OutputData::kTestFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OutputData::OutputData()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_unittest_2eproto::scc_info_OutputData.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.OutputData)
}
OutputData::OutputData(const OutputData& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      test_(from.test_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.OutputData)
}

void OutputData::SharedCtor() {
}

OutputData::~OutputData() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.OutputData)
  SharedDtor();
}

void OutputData::SharedDtor() {
}

void OutputData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OutputData& OutputData::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_unittest_2eproto::scc_info_OutputData.base);
  return *internal_default_instance();
}


void OutputData::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.OutputData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  test_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OutputData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.OutputData)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .webrtc.audioproc.Test test = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_test()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.OutputData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.OutputData)
  return false;
#undef DO_
}

void OutputData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.OutputData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .webrtc.audioproc.Test test = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->test_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->test(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.OutputData)
}

size_t OutputData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.OutputData)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .webrtc.audioproc.Test test = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->test_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->test(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OutputData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputData*>(&from));
}

void OutputData::MergeFrom(const OutputData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.OutputData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  test_.MergeFrom(from.test_);
}

void OutputData::CopyFrom(const OutputData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.OutputData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputData::IsInitialized() const {
  return true;
}

void OutputData::Swap(OutputData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OutputData::InternalSwap(OutputData* other) {
  using std::swap;
  CastToBase(&test_)->InternalSwap(CastToBase(&other->test_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string OutputData::GetTypeName() const {
  return "webrtc.audioproc.OutputData";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace audioproc
}  // namespace webrtc
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::webrtc::audioproc::Test_Frame* Arena::CreateMaybeMessage< ::webrtc::audioproc::Test_Frame >(Arena* arena) {
  return Arena::CreateInternal< ::webrtc::audioproc::Test_Frame >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::webrtc::audioproc::Test_EchoMetrics* Arena::CreateMaybeMessage< ::webrtc::audioproc::Test_EchoMetrics >(Arena* arena) {
  return Arena::CreateInternal< ::webrtc::audioproc::Test_EchoMetrics >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::webrtc::audioproc::Test_DelayMetrics* Arena::CreateMaybeMessage< ::webrtc::audioproc::Test_DelayMetrics >(Arena* arena) {
  return Arena::CreateInternal< ::webrtc::audioproc::Test_DelayMetrics >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::webrtc::audioproc::Test* Arena::CreateMaybeMessage< ::webrtc::audioproc::Test >(Arena* arena) {
  return Arena::CreateInternal< ::webrtc::audioproc::Test >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::webrtc::audioproc::OutputData* Arena::CreateMaybeMessage< ::webrtc::audioproc::OutputData >(Arena* arena) {
  return Arena::CreateInternal< ::webrtc::audioproc::OutputData >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
